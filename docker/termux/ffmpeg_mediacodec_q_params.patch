commit 9ffc1db26fcae50d11ff800a3a77dbfcbe66b26a
Author: Zhao Zhili <quinkblack@foxmail.com>
Date:   Fri Jan 10 16:47:23 2025 +0800

    avcodec/mediacodecenc: Support config qp range
    
    Signed-off-by: Zhao Zhili <zhilizhao@tencent.com>

diff --git a/libavcodec/mediacodecenc.c b/libavcodec/mediacodecenc.c
index e76ea81236..89041199e4 100644
--- a/libavcodec/mediacodecenc.c
+++ b/libavcodec/mediacodecenc.c
@@ -76,6 +76,13 @@ typedef struct MediaCodecEncContext {
     int level;
     int pts_as_dts;
     int extract_extradata;
+
+    int qp_i_min;
+    int qp_p_min;
+    int qp_b_min;
+    int qp_i_max;
+    int qp_p_max;
+    int qp_b_max;
 } MediaCodecEncContext;
 
 enum {
@@ -185,6 +192,39 @@ static int mediacodec_init_bsf(AVCodecContext *avctx)
 
 static int mediacodec_generate_extradata(AVCodecContext *avctx);
 
+static void mediacodec_set_qp_range(AVCodecContext *avctx,
+                                    FFAMediaFormat *format)
+{
+    MediaCodecEncContext *s = avctx->priv_data;
+
+    // Handle common options in AVCodecContext first.
+    if (avctx->qmin >= 0) {
+        ff_AMediaFormat_setInt32(format, "video-qp-i-min", avctx->qmin);
+        ff_AMediaFormat_setInt32(format, "video-qp-p-min", avctx->qmin);
+        ff_AMediaFormat_setInt32(format, "video-qp-b-min", avctx->qmin);
+    }
+
+    if (avctx->qmax >= 0) {
+        ff_AMediaFormat_setInt32(format, "video-qp-i-max", avctx->qmax);
+        ff_AMediaFormat_setInt32(format, "video-qp-p-max", avctx->qmax);
+        ff_AMediaFormat_setInt32(format, "video-qp-b-max", avctx->qmax);
+    }
+
+    if (s->qp_i_min >= 0)
+        ff_AMediaFormat_setInt32(format, "video-qp-i-min", s->qp_i_min);
+    if (s->qp_p_min >= 0)
+        ff_AMediaFormat_setInt32(format, "video-qp-p-min", s->qp_p_min);
+    if (s->qp_b_min >= 0)
+        ff_AMediaFormat_setInt32(format, "video-qp-b-min", s->qp_b_min);
+
+    if (s->qp_i_max >= 0)
+        ff_AMediaFormat_setInt32(format, "video-qp-i-max", s->qp_i_max);
+    if (s->qp_p_max >= 0)
+        ff_AMediaFormat_setInt32(format, "video-qp-p-max", s->qp_p_max);
+    if (s->qp_b_max >= 0)
+        ff_AMediaFormat_setInt32(format, "video-qp-b-max", s->qp_b_max);
+}
+
 static av_cold int mediacodec_init(AVCodecContext *avctx)
 {
     const char *codec_mime = NULL;
@@ -313,6 +353,9 @@ static av_cold int mediacodec_init(AVCodecContext *avctx)
         if (s->bitrate_mode == BITRATE_MODE_CQ && avctx->global_quality > 0)
             ff_AMediaFormat_setInt32(format, "quality", avctx->global_quality);
     }
+
+    mediacodec_set_qp_range(avctx, format);
+
     // frame-rate and i-frame-interval are required to configure codec
     if (avctx->framerate.num >= avctx->framerate.den && avctx->framerate.den > 0) {
         s->fps = avctx->framerate.num / avctx->framerate.den;
@@ -734,6 +777,12 @@ static const AVCodecHWConfigInternal *const mediacodec_hw_configs[] = {
     NULL
 };
 
+static const FFCodecDefault mediacodec_defaults[] = {
+    {"qmin", "-1"},
+    {"qmax", "-1"},
+    {NULL},
+};
+
 #define OFFSET(x) offsetof(MediaCodecEncContext, x)
 #define VE AV_OPT_FLAG_VIDEO_PARAM | AV_OPT_FLAG_ENCODING_PARAM
 #define COMMON_OPTION                                                                                       \
@@ -754,7 +803,18 @@ static const AVCodecHWConfigInternal *const mediacodec_hw_configs[] = {
     { "pts_as_dts", "Use PTS as DTS. It is enabled automatically if avctx max_b_frames <= 0, "              \
                     "since most of Android devices don't output B frames by default.",                      \
                     OFFSET(pts_as_dts), AV_OPT_TYPE_BOOL, {.i64 = -1}, -1, 1, VE },                         \
-
+    { "qp_i_min", "minimum quantization parameter for I frame",                                             \
+                    OFFSET(qp_i_min), AV_OPT_TYPE_INT, {.i64 = -1}, -1, INT_MAX, VE },                      \
+    { "qp_p_min", "minimum quantization parameter for P frame",                                             \
+                    OFFSET(qp_p_min), AV_OPT_TYPE_INT, {.i64 = -1}, -1, INT_MAX, VE },                      \
+    { "qp_b_min", "minimum quantization parameter for B frame",                                             \
+                    OFFSET(qp_b_min), AV_OPT_TYPE_INT, {.i64 = -1}, -1, INT_MAX, VE },                      \
+    { "qp_i_max", "maximum quantization parameter for I frame",                                             \
+                    OFFSET(qp_i_max), AV_OPT_TYPE_INT, {.i64 = -1}, -1, INT_MAX, VE },                      \
+    { "qp_p_max", "maximum quantization parameter for P frame",                                             \
+                    OFFSET(qp_p_max), AV_OPT_TYPE_INT, {.i64 = -1}, -1, INT_MAX, VE },                      \
+    { "qp_b_max", "maximum quantization parameter for B frame",                                             \
+                    OFFSET(qp_b_max), AV_OPT_TYPE_INT, {.i64 = -1}, -1, INT_MAX, VE },                      \
 
 #define MEDIACODEC_ENCODER_CLASS(name)              \
 static const AVClass name ## _mediacodec_class = {  \
@@ -777,6 +837,7 @@ const FFCodec ff_ ## short_name ## _mediacodec_encoder = {              \
     .priv_data_size   = sizeof(MediaCodecEncContext),                   \
     .p.pix_fmts       = avc_pix_fmts,                                   \
     .color_ranges   = AVCOL_RANGE_MPEG | AVCOL_RANGE_JPEG,              \
+    .defaults         = mediacodec_defaults,                            \
     .init             = mediacodec_init,                                \
     FF_CODEC_RECEIVE_PACKET_CB(mediacodec_encode),                      \
     .close            = mediacodec_close,                               \
